Initial Test: Time and output

    Output: 65.21

    real    0m20.822s
    user    0m20.730s
    sys     0m0.005s

Eliminating Unnecessary Work

    How much of a speedup do you get?
        The program ran 20.64 seconds faster
    Why do you think it’s so dramatic?
        The program runs so much faster because instead of creating a new variable, copying it, storing it, and accessing it every time x is called the "const &" makes it so that the variable is never changed and can be referenced instead of making a new copy and storing it every time x is called.

    Output: 65.21

    real    0m0.182s
    user    0m0.177s
    sys     0m0.003s


    Set Rows to 800
    Output: 5.39

    real    0m12.755s
    user    0m9.245s
    sys     0m3.439s


    Fix other functions
    Output: 5.39

    real    0m6.958s
    user    0m6.921s
    sys     0m0.005s

    How much more of a speedup do these changes yield? 
        The program ran 5.797 seconds faster. 
    Why isn’t it as significant?
        The change isn't as significant becasue the other variables changed are not called as many times and in as many places as x is.
        The laplacian function uses x five times and it is called much later on in the code which makes it so that you double the amount of times you are copying and storing x.

Cache Efficiency
    Output: 5.39

    real    0m2.999s
    user    0m2.978s
    sys     0m0.003s

    How much faster does optimize run with this change? 
        The code runs 3.959 seconds faster. 
    Why do you think that is?
        Because i represents rows and j represents columns and the data is stored one row after another, accessing columns first causes the program to jump to each row and only select one number from it. 
        Because all this data cannot fit inside the cache it takes longer to retrive all the informaiton.

Vectorization

    -Ofast
    Output:5.39

    real    0m2.817s
    user    0m2.795s
    sys     0m0.007s

    Remove the if (...) continue;
    5.39

    real    0m1.694s
    user    0m1.676s
    sys     0m0.007s

    How much of a speedup results, and why?
        The program ran 1.305 seconds faster. 
        The new loop declaration is more efficient. 
        The old if(...)contunue statement was accessing memeory an extra time in order to determine the bounds. 
        
Threading
    2 threads:
    5.39

    real    0m0.897s
    user    0m1.760s
    sys     0m0.011s

    4 threads:
    5.39

    real    0m0.484s
    user    0m1.870s
    sys     0m0.013s

    8 threads:
    5.39

    real    0m0.256s
    user    0m1.931s
    sys     0m0.019s

    16 threads:
    5.39

    real    0m0.150s
    user    0m2.169s
    sys     0m0.019s

    32 threads:
    5.39

    real    0m0.115s
    user    0m3.163s
    sys     0m0.047s

    What sort of speedup do you get when you run with 2 threads? 4? 8? 16?
        See readouts above. 
    Why do you think the diminishment of returns is so severe?
        Once the program is being run on multiple threads adding more threads dosn't yeild as good of returns because there are only so many things that can be done in parrallel. 
        After the majority of tasks are being handled on differant threads the user time starts to increase which inidicates that there are cores waiting for tasks to do. 

Other Optimizations
    Reduce redundant calculations
    8 threads:
    5.39

    real    0m0.251s
    user    0m1.886s
    sys     0m0.021s
    No noticable change

    Running through CMakeLists with -Ofast -DNDEBUG -fopenmp
    5.39

    real    0m0.164s
    user    0m1.159s
    sys     0m0.013s

    How much more of a speedup were you able to get? 
        0.087 seconds faster
    What seemed to help the most, and why do you think that’s the case?
        making the program using CMake with all the correct comiler flags seemed to help the most. 
        The other optimizations I was making we very minor so for a small program they would'nt change that much.
    Did you find out anything interesting or unexpected during the course of this optimization?
        I learned that variables that are called multiple times should have great care taken in their declaration. 
        I was very supprosed by how much of a differant making this constant references made.
        It was also very cool to see how threading works and the power of multiple cores.
        